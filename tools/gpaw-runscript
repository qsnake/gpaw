#!/usr/bin/env python
# Emacs: treat this as -*- python -*-

import os
import sys
import socket
import re
from optparse import OptionParser

defaults = { 'err'   : None,
             'mail'  : None,
             'mem'   : None,
             'name'  : None,
             'nodes' : 2,
             'out'   : None,
             'qsys'  : 'pbs',
             'script': 'run.py',
             'time'  : 86400, # one day in seconds
             'wd'    : None
             }

hosts = { 'batman'             : 'pbs',
          'c551'               : 'murska',
          'c552'               : 'murska',
          'c553'               : 'murska',
          'c554'               : 'murska',
          'louhi'              : 'louhi',
          'opaali.phys.jyu.fi' : 'sge',
          'sepeli.csc.fi'      : 'sepeli'
          }

env = {'PYTHONPATH'      : None,
       'GPAW_PYTHON'     : None, 
       'GPAW_SETUP_PATH' : None
       }

set = defaults

#......................................................
# functions

def dhms(secs):
    """return days,hours,minutes and seconds"""
    dhms = [0,0,0,0]
    dhms[0] = int(secs // 86400)
    s = secs % 86400
    dhms[1] = int(s // 3600)
    s = secs % 3600
    dhms[2] = int(s // 60)
    s = secs % 60
    dhms[3] = int(s+.5)
    return dhms

def s_from_dhms(time):
    """return seconds from dhms"""
    dhms_s = { 's' : 1, 'm' : 60, 'h' : 3600, 'd' : 86400 }
    time = time.lower()
    word_list = re.findall('\d*[^\d]*',time)
    seconds=0 
    for word in word_list:
        if word != '':
            sec = 1
            for t in dhms_s.keys():
                nw = word.replace(t,'')
                if nw != word:
                    sec = dhms_s[t]
                    word = nw
                    break
            try:
                seconds += int(word) * sec
            except:
                raise RuntimeError, 'unknown format in timestring ' + time
    return seconds
    
class RunScript:
    def __init__(self, set, env, name=None):
        if not hasattr(self,set['qsys']):
            raise RuntimeError, "unkown system >"+set['qsys']+"<"
        if name is None:
            name = 'run.'+set['qsys']
        f = open(name,'w')
        call = "self."+set['qsys']+"(f,set,env)"
        eval(call)
        f.close()
        print name,"written"

    def louhi(self,f,set,env):
        size=int((set['nodes']+1)/2)
        print >> f,"#!/bin/csh"
        print >> f,"#PBS -N",set['name']
        print >> f,"#PBS -l size=%d" % size
        print >> f,"#PBS -l walltime=" + str(set['time'])
        print >> f,"#PBS -o",set['out']
        print >> f,"#PBS -e",set['err']
        print >> f
        print >> f,"module load netcdf"
        print >> f,"module load ASE"
        print >> f,"setenv GPAW_SETUP_PATH",env['GPAW_SETUP_PATH']
        print >> f,"setenv PYTHONPATH ${PYTHONPATH}:"+env['PYTHONPATH']
        print >> f,"setenv GPAW_PYTHON",env['GPAW_PYTHON']
        print >> f
        print >> f,"cd",set['wd']
        print >> f,"yod $GPAW_PYTHON",set['script']
        
    def louhi_pre(self,f,set,env):
        size=int((set['nodes']+1)/2)
        print >> f,"#!/bin/csh"
        print >> f,"#PBS -N",set['name']
        print >> f,"#PBS -l size=%d" % size
        print >> f,"#PBS -l walltime=" + str(set['time'])
        print >> f,"#PBS -o",set['out']
        print >> f,"#PBS -e",set['err']
        print >> f,"""
module load gpaw
echo $GPAW_SETUP_PATH
echo $GPAW_PYTHON

setenv MPICH_PTL_UNEX_EVENTS 60000
setenv MPICH_UNEX_BUFFER_SIZE 400M
"""
        print >> f,"cd",set['wd']
        print >> f,"yod $GPAW_PYTHON",set['script']
        
    def murska(self,f,set,env):
        # Michaels defaults
        if not env['GPAW_SETUP_PATH']:
            env['GPAW_SETUP_PATH'] = '/v/linux26_x86_64/appl/nano/gpaw/setups'
        if not env['PYTHONPATH']:
            env['PYTHONPATH'] = '${PYTHONPATH}:/wrk/walter/gridpaw/trunk'
        if not env['GPAW_PYTHON']:
            env['GPAW_PYTHON'] = '/wrk/walter/gridpaw/trunk/build/bin.linux-x86_64-2.4/gpaw-python'
            
        print >> f,"#!/bin/csh"
        print >> f,"#BSUB -n%d" % set['nodes']
        hs = dhms(set['time'])
        print >> f,"#BSUB -W %d:%d" % (hs[0]*24+hs[1],hs[2])
        print >> f,"#BSUB -J",set['name']
        if set['mail'] is not None:
            print >> f,"#BSUB -u",set['mail']
        print >> f,"#BSUB -e ",set['err']+'_%J'
        print >> f,"#BSUB -o ",set['out']+'_%J'
        if set['mem']:
            print >> f, '#BSUB -ext "SLURM[constraint=mediummem|bigmem]"'
        print >> f,"module load ASE"
        print >> f,"setenv GPAW_SETUP_PATH",env['GPAW_SETUP_PATH']
        print >> f,"setenv PYTHONPATH ${PYTHONPATH}:"+env['PYTHONPATH']
        print >> f,"setenv GPAW_PYTHON",env['GPAW_PYTHON']
        print >> f,"mpirun -srun $GPAW_PYTHON",set['script']
      
    def pbs(self,f,set,env):
        print >> f,"#PBS -N "+set['name']
        print >> f,"#PBS -l ncpus="+str(set['nodes'])
        print >> f,"#PBS -l walltime="""+str(set['time'])
        print >> f,"#PBS -m bea"
        if set['mail'] is not None:
            print >> f,"#PBS -M",set['mail']
##        print >> f,"#PBS -o",set['out']
        print >> f,"#PBS -e",set['err']
        print >> f,"""
# change to the directory where you submitted the job
cd""",set['wd']
        print >> f,'export OUT="'+set['out']+'"'
        print >> f,"echo \"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\" >> $OUT"
        print >> f,"echo \"Current working directory is `pwd`\" >> $OUT"
        print >> f,"echo \"Running on `hostname`\" >> $OUT"
        print >> f,"""
#include the full path to the name of your MPI program
. /usr/share/modules/init/bash
module add mpt
module add mkl
unset CC CFLAGS LDFLAGS

# With the upgrade of the queue system, one problem arised and this
# requires everyone to add one line in the run scripts:
unset PBS_NODEFILE

"""
        print >> f,"date >> $OUT"
        print >> f,"export GPAW_PYTHON=~/gridpaw/build/bin.linux-ia64-2.4/gpaw-python"
        print >> f,"mpirun -np",set['nodes'],"$GPAW_PYTHON",set['script'],\
              ">> $OUT"
        print >> f,"date >> $OUT"
        print >> f,'echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" >> $OUT'
        print >> f,"exit 0"

    def sepeli(self,f,set,env):
        print >> f,"#$ -N",set['name']
        print >> f,"#$ -cwd"
        print >> f,"#$ -j y"
        print >> f,"#$ -pe mvapich-gnu64",set['nodes']
        print >> f,"#$ -S /bin/csh"
        print >> f,"#$ -R y"
        print >> f,"#$ -V"
        print >> f,"#$ -l h_rt=23:48:00"
        print >> f,"#$ -l s_rt=23:45:00"
        print >> f,"#$ -e",set['err']+'_$JOB_ID'
        print >> f,"setenv out",'"'+set['out']+'_$JOB_ID"'
        print >> f,"""
cat $TMPDIR/machines > $out
use ASE
setenv GPAW_SETUP_PATH \"/mnt/nas2/wrk/walter/gridpaw/setups/generate:/mnt/nas2/wrk/walter/gridpaw/setups/gpaw-setups-0.3\"
setenv PYTHONPATH \"/mnt/nas2/wrk/walter/gridpaw/trunk:/home/u2/univ2/jyy/walter/gridpaw/trunk:${PYTHONPATH}\"
setenv GPAW_MPI_COMMAND \"mpirun -np 4 %(job)s &\"
setenv GPAW_PYTHON /mnt/nas2/wrk/walter/gridpaw/trunk/build/bin.linux-x86_64-2.4/gpaw-python
"""
        print >> f,"mpirun -np",set['nodes'],"$GPAW_PYTHON",set['script'],\
              ">> $out"
        
    def sge(self,f,set,env):
        print >> f,"#!/bin/bash"
        print >> f,"#$ -S /bin/bash"
        print >> f,"#$ -N",set['name']
        print >> f,"#$ -cwd"
        print >> f,"#$ -o",set['out']+'_$JOB_ID'
        print >> f,"#$ -e",set['err']+'_$JOB_ID'
        if set['mail'] is not None:
            print >> f,"#$ -M",set['mail']
        print >> f,"#$ -m be"
        print >> f,"#$ -pe mpich",set['nodes']
        if set['mem']:
            print >> f, '#$ -q new8G'
        print >> f,"cd",set['wd']
        print >> f,"""
echo \"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\"
echo \"We've got $NSLOTS processor(s) on compute nodes: \";
echo "MPICH machines file: ${TMPDIR}/machines";
echo; cat  $TMPDIR/machines; echo

# initialize environment
. /opt/ASE/ASE.sh
# source /opt/openmpi/openmpi-path64.sh # does not exist anymore
export MPIHOME=/opt/openmpi/path64
export PATH=$MPIHOME/bin/:$PATH
export LD_LIBRARY_PATH=$MPIHOME/lib64:$MPIHOME/lib:$LD_LIBRARY_PATH

GPAW_HOME=$HOME/gridpaw
export GPAW_SETUP_PATH=$GPAW_HOME/setups/generate:$GPAW_HOME/setups/gpaw-setups-0.3/setups
if [ ${PYTHONPATH:-unknown} != unknown ]
then
    export PYTHONPATH=$GPAW_HOME:$PYTHONPATH
else
    export PYTHONPATH=$GPAW_HOME
fi
export PATH=$PATH:$GPAW_HOME/tools/
export GPAW_PYTHON=$GPAW_HOME/build/bin.linux-x86_64-2.3/gpaw-python
"""
        print >> f, 'export PYTHONPATH=$PYTHONPATH:'+env['PYTHONPATH']
        print >> f, 'date'
        print >> f,"mpirun -np",set['nodes'],\
              "~/gridpaw/build/bin.linux-x86_64-2.3/gpaw-python",\
              set['script']
        print >> f,"""date
echo \"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\"
"""        

# ............................................................
# program

# handle command line options

parser = OptionParser(usage='%prog [options] [script nnodes]')
parser.add_option("-m", "--mail", dest='mail',
                  help='Where to send an email about starting/ending of the job (def: read from environment variable GPAW_MAIL)')
parser.add_option("-M", "--Memory", action='count', default=None,
                  help='request large memory nodes (host specific)')
parser.add_option("-n", "--name", dest='name',
                  help='Name of the job (def: name of parent directory)')
parser.add_option("-o", "--outfile", dest='outfile',
                  help='Name of the output file (def: script.out)')
parser.add_option("-q", "--qsys", dest='qsys',
                  help='queue system (def: try to guess)')
parser.add_option("-t", "--time", dest='time',
                  help='Time (def: 86400=1140m=24h=1d=one day)')
opt, args = parser.parse_args()
##print "opt=",opt
##print "args=",args

if opt.mail:
    set['mail'] = str(opt.mail)

if opt.Memory is not None:
    set['mem'] = True

if opt.name:
    set['name'] = str(opt.name)

if opt.outfile:
    set['out'] = str(opt.outfile)

if opt.time:
    set['time'] = s_from_dhms(opt.time)

if len(args):
    set['script'] = args[0]
    if len(args) > 1:
        set['nodes'] = int(args[1])

# ............................................................

# try to determine the system
if opt.qsys:
    set['qsys']=opt.qsys
else:
    host = socket.gethostname().split('-')[0]
    if hosts.has_key(host):
        set['qsys']=hosts[host]
        print 'hostname',host,'found,',
    else:
        print "Host "+str(host)+" unknown, try -q option. Allowed names are:"
        p = re.compile('__')
        for host in dir(RunScript):
            if not p.match(host):
                print '',host
        sys.exit()
print 'using',set['qsys']

# ............................................................
# get environment variables

for key in env:
    if key in os.environ.keys():
        env[key] = os.environ[key]
##print "env=",env

# ............................................................

if set['mail'] is None and os.environ.has_key('GPAW_MAIL'):
    set['mail'] = str(os.environ['GPAW_MAIL'])

# set output files
if set['out'] is None:
    set['out'] = set['script']+".out"
if set['err'] is None:
    set['err'] = set['script']+".err"

# get the name from current working directory
if set['wd'] is None:
    set['wd'] = os.getcwd()
if set['name'] is None:
    name = os.getcwd().split('/')[-1]
    # avoid binning with a number
    if name[0].isdigit():
        name = 'j' + name
    set['name']=name

RunScript(set,env)



